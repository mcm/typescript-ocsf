# OCSF Enum Validation Specification

> **⚠️ NOTE:** This document contains the detailed investigation findings. The implementation plan has been corrected and merged into `ENUM_VALIDATION_PLAN.md`, which should be used as the primary reference for implementation.

## Executive Summary

This specification documents the investigation into enum handling in typescript-ocsf. After thorough analysis and user correction, we confirmed that:

1. **Enum inheritance is BROKEN** - Parent enum values are lost instead of merged
2. **OCSF requires merging** - Events inherit base values (0=Unknown, 99=Other) from dictionary
3. **The fix is in the resolver** - Change `??` to proper enum merging

See `ENUM_VALIDATION_PLAN.md` for the corrected implementation plan.

## 1. OCSF Enum Model

### 1.1 How Enums Are Defined

OCSF enums are defined in two places:

1. **Global Dictionary** (`dictionary.json`): Contains canonical attribute definitions including enum values
2. **Event/Object Overrides**: Individual event/object JSON files can override enum values

### 1.2 Enum Merging Rules

According to the parser code analysis:

```typescript
const merged = { ...dictDef, ...attrOverrides };
```

**Rule**: When an event defines an `enum` property for an attribute, it **COMPLETELY REPLACES** the dictionary enum, not merges with it.

**Evidence**:
- `incident_finding.json` defines `status_id.enum` with values 1-5 only
- Dictionary defines `status_id.enum` with values 0, 1, 2, 99
- The incident_finding enum does NOT include 0 or 99

### 1.3 The "OTHER: 99" Myth

**Current assumption (INCORRECT)**: All enum fields have `OTHER: 99` for vendor-specific values.

**Reality**:
- NOT all enums have `OTHER: 99`
- NOT all enums have `UNKNOWN: 0`
- Enums are event-specific and may define only the exact values they support

**Examples**:

| Enum | Source | Values | Has 0? | Has 99? |
|------|--------|--------|--------|---------|
| `status_id` (dictionary) | dictionary.json | 0, 1, 2, 99 | ✅ | ✅ |
| `status_id` (incident_finding) | incident_finding.json | 1, 2, 3, 4, 5 | ❌ | ❌ |
| `activity_id` (base_event) | base_event.json | 0, 99 | ✅ | ✅ |
| `activity_id` (file_activity) | file_activity.json | 1-14 | ❌ | ❌ |
| `action_id` (dictionary) | dictionary.json | 0, 1, 2, 99 | ✅ | ✅ |

### 1.4 Sibling Reconciliation Implications

The `reconcileSiblings` function has special handling for `id === 99`:

```typescript
if (id === 99) {
  // OTHER: preserve custom label as-is, keep ID
  result[idField] = 99;
}
```

And for unknown labels:

```typescript
if (entry) {
  // Known label found
} else {
  // Unknown label -> map to OTHER (99)
  result[idField] = 99;
}
```

**Problem**: This assumes ALL enums support value 99, which is not true for enums like `incident_finding.status_id`.

## 2. Current Implementation Analysis

### 2.1 What's Generated Now

**Shared Enums** (53 files in `src/v1_7/enums/`):
- Extracted from dictionary.json
- Only for `_id` attributes with enum definitions
- Example: `src/v1_7/enums/status_id.ts`

```typescript
export const StatusId = {
  UNKNOWN: 0,
  SUCCESS: 1,
  FAILURE: 2,
  OTHER: 99,
} as const;
```

**Event-Specific Activity Enums** (49 files):
- Generated ONLY for `activity_id` attributes
- ONLY when enum has > 2 values
- Generated by `emitEventEnumFile()` which **forcibly adds 0 and 99**
- Example: `src/v1_7/enums/incident_finding_activity_id.ts`

```typescript
export const IncidentFindingActivityId = {
  UNKNOWN: 0,        // ❌ NOT in schema!
  CREATE: 1,
  UPDATE: 2,
  CLOSE: 3,
  OTHER: 99,         // ❌ NOT in schema!
} as const;
```

### 2.2 Event Schema Generation

Events use inline `*_LABELS` constants:

```typescript
const STATUS_ID_LABELS: Record<number, string> = {
  1: "New",
  2: "In Progress",
  3: "On Hold",
  4: "Resolved",
  5: "Closed",
};
```

And Zod schemas are just `z.number().int()` with NO enum validation:

```typescript
status_id: z.number().int(),  // ❌ Accepts ANY integer
```

### 2.3 What's Wrong

1. **No enum validation**: Fields typed as `z.number().int()` accept values outside the defined enum
2. **Incorrect enum generation**: `emitEventEnumFile()` adds 0 and 99 when not in schema
3. **Incomplete enum coverage**: Only `activity_id` gets event-specific enums; other enums (like `status_id`, `severity_id`) don't
4. **Sibling reconciliation assumptions**: Code assumes 99 is always valid for "unknown label" fallback

## 3. OCSF Schema Examples

### Example 1: incident_finding.status_id

**Dictionary definition** (dictionary.json):
```json
"status_id": {
  "enum": {
    "0": { "caption": "Unknown" },
    "1": { "caption": "Success" },
    "2": { "caption": "Failure" },
    "99": { "caption": "Other" }
  }
}
```

**Event override** (incident_finding.json):
```json
"status_id": {
  "enum": {
    "1": { "caption": "New" },
    "2": { "caption": "In Progress" },
    "3": { "caption": "On Hold" },
    "4": { "caption": "Resolved" },
    "5": { "caption": "Closed" }
  }
}
```

**Result**: incident_finding.status_id ONLY accepts 1-5. No 0, no 99.

### Example 2: file_activity.activity_id

**Dictionary definition**:
```json
"activity_id": {
  "enum": {
    "0": { "caption": "Unknown" },
    "99": { "caption": "Other" }
  }
}
```

**Event override** (file_activity.json):
```json
"activity_id": {
  "enum": {
    "1": { "caption": "Create" },
    "2": { "caption": "Read" },
    "3": { "caption": "Update" },
    "4": { "caption": "Delete" },
    "5": { "caption": "Rename" },
    "6": { "caption": "Set Attributes" },
    "7": { "caption": "Set Security" },
    "8": { "caption": "Get Attributes" },
    "9": { "caption": "Get Security" },
    "10": { "caption": "Encrypt" },
    "11": { "caption": "Decrypt" },
    "12": { "caption": "Mount" },
    "13": { "caption": "Unmount" },
    "14": { "caption": "Open" }
  }
}
```

**Result**: file_activity.activity_id ONLY accepts 1-14. No 0, no 99.

### Example 3: base_event.severity_id

**Dictionary definition**:
```json
"severity_id": {
  "enum": {
    "0": { "caption": "Unknown" },
    "1": { "caption": "Informational" },
    "2": { "caption": "Low" },
    "3": { "caption": "Medium" },
    "4": { "caption": "High" },
    "5": { "caption": "Critical" },
    "6": { "caption": "Fatal" },
    "99": { "caption": "Other" }
  }
}
```

**No event override** - base_event.json doesn't define enum for severity_id

**Result**: severity_id accepts 0, 1, 2, 3, 4, 5, 6, 99 (from dictionary)

## 4. Proposed Solution

### 4.1 Architecture Decision

**Use Event-Specific Merged Enums**

Generate enum types that reflect the EXACT values defined in the resolved event schema (after merging dictionary + event overrides).

### 4.2 Generation Strategy

For EACH enum field in EACH event/object:

1. **Determine final enum values**: After merging dictionary + event overrides
2. **Generate event-specific enum**: If values differ from dictionary
3. **Use global enum**: If values match dictionary exactly
4. **Apply Zod validation**: Use `.refine()` or `.union()` with literal values

### 4.3 TypeScript Output Pattern

**Option A: Zod Literal Union (Strict)**
```typescript
// For incident_finding.status_id
status_id: z.union([
  z.literal(1),
  z.literal(2),
  z.literal(3),
  z.literal(4),
  z.literal(5),
]) as z.ZodType<1 | 2 | 3 | 4 | 5>
```

**Option B: Enum Constant Reference (Preferred)**
```typescript
// Generate event-specific enum
export const IncidentFindingStatusId = {
  NEW: 1,
  IN_PROGRESS: 2,
  ON_HOLD: 3,
  RESOLVED: 4,
  CLOSED: 5,
} as const;

export type IncidentFindingStatusId =
  (typeof IncidentFindingStatusId)[keyof typeof IncidentFindingStatusId];

// In event schema
import { IncidentFindingStatusId } from '../enums/incident_finding_status_id.js';

status_id: z.nativeEnum(IncidentFindingStatusId)
```

**Option C: Runtime Validation (Most Flexible)**
```typescript
const INCIDENT_FINDING_STATUS_ID_VALUES = [1, 2, 3, 4, 5] as const;

status_id: z.number().int().refine(
  (val) => INCIDENT_FINDING_STATUS_ID_VALUES.includes(val),
  { message: "Invalid status_id value" }
) as z.ZodType<1 | 2 | 3 | 4 | 5>
```

### 4.4 Recommended Approach

**Hybrid Solution**:

1. **Generate event-specific enum files** for ALL enum attributes that differ from dictionary
   - Naming: `{EventName}{AttributeName}.ts` (e.g., `incident_finding_status_id.ts`)
   - Include ONLY the exact values from the schema (no forced 0 or 99)

2. **Use Zod validation** with the enum type:
   ```typescript
   status_id: z.nativeEnum(IncidentFindingStatusId)
   ```

3. **Keep global enums** for reference but don't force them onto events

4. **Update sibling reconciliation** to handle missing 99:
   ```typescript
   } else {
     // Unknown label
     const hasOther = Object.keys(labels).includes('99');
     if (hasOther) {
       result[idField] = 99;
     } else {
       // No OTHER value - this is an error
       throw new Error(
         `Unknown ${labelField}='${labelVal}' and no OTHER (99) value defined`
       );
     }
   }
   ```

## 5. Implementation Examples

### Example 1: incident_finding.status_id

**Generated enum file** (`src/v1_7/enums/incident_finding_status_id.ts`):
```typescript
/** Incident Finding status_id values. */
export const IncidentFindingStatusId = {
  /** The service desk has received the incident but has not assigned it to an agent. */
  NEW: 1,
  /** The incident has been assigned to an agent but has not been resolved. */
  IN_PROGRESS: 2,
  /** The incident requires some information or response from the user. */
  ON_HOLD: 3,
  /** The service desk has confirmed that the incident is resolved. */
  RESOLVED: 4,
  /** The incident is resolved and no further action is necessary. */
  CLOSED: 5,
} as const;

export type IncidentFindingStatusId =
  (typeof IncidentFindingStatusId)[keyof typeof IncidentFindingStatusId];

export const IncidentFindingStatusIdLabels: Record<number, string> = {
  1: "New",
  2: "In Progress",
  3: "On Hold",
  4: "Resolved",
  5: "Closed",
};
```

**Event schema** (`src/v1_7/events/incident_finding.ts`):
```typescript
import { IncidentFindingStatusId } from '../enums/incident_finding_status_id.js';

// In Zod schema:
status_id: z.nativeEnum(IncidentFindingStatusId)
```

**TypeScript type inference**:
```typescript
type T = z.infer<typeof IncidentFinding>;
// T.status_id is type: 1 | 2 | 3 | 4 | 5
```

**Validation behavior**:
```typescript
IncidentFinding.parse({ status_id: 1 }); // ✅ Valid
IncidentFinding.parse({ status_id: 99 }); // ❌ ZodError: Invalid enum value
```

### Example 2: base_event.severity_id (unchanged)

**Uses global enum** (`src/v1_7/enums/severity_id.ts`):
```typescript
export const SeverityId = {
  UNKNOWN: 0,
  INFORMATIONAL: 1,
  LOW: 2,
  MEDIUM: 3,
  HIGH: 4,
  CRITICAL: 5,
  FATAL: 6,
  OTHER: 99,
} as const;
```

**Event schema**:
```typescript
import { SeverityId } from '../enums/severity_id.js';

severity_id: z.nativeEnum(SeverityId)
```

### Example 3: Sibling Reconciliation

**Old behavior** (assumes 99 always exists):
```typescript
} else {
  // Unknown label -> map to OTHER (99)
  result[idField] = 99;
  // This BREAKS for incident_finding.status_id!
}
```

**New behavior** (checks if 99 is valid):
```typescript
} else {
  // Unknown label
  const hasOther = Object.keys(labels).includes('99');
  if (hasOther) {
    result[idField] = 99;
  } else {
    // Validation will fail later in Zod
    // Leave the label as-is and let Zod validation catch it
    // OR throw immediately:
    throw new Error(
      `${labelField}='${labelVal}' is not a known value and no OTHER (99) is defined`
    );
  }
}
```

## 6. Generator Changes Required

### 6.1 Parser Changes (parser.ts)

**Current**: Already correctly merges enums from dictionary + event overrides.

**Action**: No changes needed.

### 6.2 Enum Emitter Changes (enum-emitter.ts)

**Current**: `emitEventEnumFile()` forces UNKNOWN (0) and OTHER (99).

**Change**: Create a new function that generates exact enum values:

```typescript
export function emitExactEnumFile(
  eventClassName: string,
  attrName: string,
  values: ParsedEnumValue[],
): string {
  const enumName = `${eventClassName}${toPascalCaseAttr(attrName)}`;
  const lines: string[] = [];

  lines.push(`/** ${eventClassName} ${attrName} values. */`);
  lines.push(`export const ${enumName} = {`);

  for (const val of values) {
    const member = toEnumMember(val.caption);
    if (val.description) {
      lines.push(`  /** ${val.description} */`);
    }
    lines.push(`  ${member}: ${val.value},`);
  }

  lines.push("} as const;");
  lines.push("");
  lines.push(`export type ${enumName} = (typeof ${enumName})[keyof typeof ${enumName}];`);
  lines.push("");

  // Label mapping (exact values only)
  lines.push(`export const ${enumName}Labels: Record<number, string> = {`);
  for (const val of values) {
    lines.push(`  ${val.value}: ${JSON.stringify(val.caption)},`);
  }
  lines.push("};");
  lines.push("");

  return lines.join("\n");
}
```

### 6.3 Generator Changes (generate.ts)

**Current**: Only generates event-specific enums for `activity_id`.

**Change**: Generate event-specific enums for ALL enum attributes:

```typescript
// Emit per-event enums (for all attributes with enum overrides)
for (const event of schema.events.values()) {
  for (const attr of event.attributes) {
    if (attr.enumValues && attr.enumValues.length > 0) {
      // Check if values differ from global dictionary enum
      const globalEnum = schema.enums.get(attr.name);
      const needsEventEnum = !globalEnum ||
        !enumValuesEqual(attr.enumValues, globalEnum.values);

      if (needsEventEnum) {
        const content = emitExactEnumFile(
          event.className,
          attr.name,
          attr.enumValues
        );
        const fileName = `${toFileName(event.className)}_${toFileName(attr.name)}.ts`;
        writeFileSync(join(enumsDir, fileName), content);
      }
    }
  }
}
```

### 6.4 Event Emitter Changes (event-emitter.ts)

**Current**: Uses `z.number().int()` for all integer fields.

**Change**: Import and use enum types:

```typescript
// Determine Zod type
let zodType: string;
if (attr.enumValues && attr.enumValues.length > 0) {
  // Check if event-specific enum exists
  const eventEnumName = `${event.className}${toPascalCaseAttr(attr.name)}`;
  const globalEnumName = toClassName(attr.name);

  // Prefer event-specific enum, fallback to global
  const enumName = eventNeedsSpecificEnum(attr)
    ? eventEnumName
    : globalEnumName;

  zodType = `z.nativeEnum(${enumName})`;
  // Add import
  enumImports.add({ name: enumName, file: `${toFileName(enumName)}.ts` });
} else if (attr.objectType) {
  // ... existing object handling
} else {
  zodType = mapOcsfTypeToZod(attr.ocsfType);
}
```

### 6.5 Sibling Reconciliation Changes (sibling.ts)

**Current**: Assumes 99 is always valid for unknown labels.

**Change**: Check if 99 exists before using it:

```typescript
} else if (hasLabel) {
  // Only label provided: reverse-lookup ID
  const labelStr = String(labelVal);
  const entry = Object.entries(labels).find(
    ([, lbl]) => lbl.toLowerCase() === labelStr.toLowerCase(),
  );

  if (entry) {
    result[idField] = Number(entry[0]);
    result[labelField] = entry[1];
  } else {
    // Unknown label
    const hasOther = '99' in labels;
    if (hasOther) {
      result[idField] = 99;
      // Preserve original label
    } else {
      // No OTHER value defined - this is invalid
      throw new Error(
        `Unknown ${labelField}='${labelVal}' and enum does not support OTHER (99)`
      );
    }
  }
}
```

## 7. Validation Behavior Comparison

### Current Behavior

```typescript
const data = {
  status_id: 999,  // Invalid value
  // ... other fields
};

IncidentFinding.parse(data);
// ✅ Passes (WRONG!)
```

### Desired Behavior

```typescript
const data = {
  status_id: 999,  // Invalid value
};

IncidentFinding.parse(data);
// ❌ ZodError: Invalid enum value. Expected 1 | 2 | 3 | 4 | 5, received 999
```

```typescript
const data = {
  status: "Unknown Label",  // Not in enum
};

IncidentFinding.parse(data);
// ❌ Error: Unknown status='Unknown Label' and enum does not support OTHER (99)
```

## 8. Migration Considerations

### Breaking Changes

1. **Type narrowing**: Fields currently typed as `number` become literal unions (e.g., `1 | 2 | 3`)
2. **Runtime validation**: Values outside enum range now rejected
3. **Sibling reconciliation**: Unknown labels without OTHER (99) now throw errors

### Backwards Compatibility

**Option**: Add a compatibility mode:

```typescript
export interface ParseOptions {
  strictEnums?: boolean;  // Default: true in v1.0.0, false in v0.x
}

export function createIncidentFinding(options?: ParseOptions) {
  const schema = options?.strictEnums === false
    ? IncidentFindingLoose  // Uses z.number().int()
    : IncidentFinding;      // Uses z.nativeEnum()

  return schema;
}
```

## 9. Testing Strategy

### Unit Tests

```typescript
describe('IncidentFinding.status_id', () => {
  it('accepts valid status_id values', () => {
    for (const id of [1, 2, 3, 4, 5]) {
      expect(() => IncidentFinding.parse({
        status_id: id,
        // ... required fields
      })).not.toThrow();
    }
  });

  it('rejects invalid status_id values', () => {
    for (const id of [0, 6, 99, 999]) {
      expect(() => IncidentFinding.parse({
        status_id: id
      })).toThrow(ZodError);
    }
  });

  it('reconciles known status label to id', () => {
    const result = IncidentFinding.parse({
      status: "New",
      // ... required fields
    });
    expect(result.status_id).toBe(1);
  });

  it('rejects unknown status label (no OTHER)', () => {
    expect(() => IncidentFinding.parse({
      status: "Custom Status"
    })).toThrow(/does not support OTHER/);
  });
});
```

### Integration Tests

```typescript
describe('Enum generation correctness', () => {
  it('incident_finding.status_id has exact values from schema', () => {
    const values = Object.values(IncidentFindingStatusId);
    expect(values).toEqual([1, 2, 3, 4, 5]);
    expect(values).not.toContain(0);
    expect(values).not.toContain(99);
  });

  it('base_event.severity_id has dictionary values', () => {
    const values = Object.values(SeverityId);
    expect(values).toContain(0);   // UNKNOWN
    expect(values).toContain(99);  // OTHER
  });
});
```

## 10. Summary & Recommendations

### Key Findings

1. **OCSF enums are event-specific**: Events can completely override dictionary enum values
2. **OTHER (99) is not universal**: Many enums don't support OTHER
3. **Current code is incorrect**: Forcibly adds 0 and 99 to enums that don't define them
4. **No validation exists**: Fields accept any integer value

### Recommended Actions

**Phase 1: Fix Enum Generation**
- [ ] Remove forced 0/99 from `emitEventEnumFile()`
- [ ] Generate event-specific enums for ALL attributes (not just activity_id)
- [ ] Use exact values from schema

**Phase 2: Add Zod Validation**
- [ ] Import enum types in event schemas
- [ ] Use `z.nativeEnum()` for enum validation
- [ ] Update type-map to handle enum attributes

**Phase 3: Fix Sibling Reconciliation**
- [ ] Check if 99 exists before using it
- [ ] Throw error or use strict mode for unknown labels

**Phase 4: Testing**
- [ ] Add unit tests for enum validation
- [ ] Verify all 102 generated enums are correct
- [ ] Test sibling reconciliation edge cases

### Priority

**HIGH**: This is a correctness issue. The library currently accepts invalid data that would be rejected by compliant OCSF implementations.

**Impact**: Users relying on type safety are not getting validation for enum fields.

**Effort**: Medium - requires changes across parser, emitters, and reconciliation logic.
